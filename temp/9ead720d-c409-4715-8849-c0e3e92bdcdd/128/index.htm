<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=unicode">
<title>Process.killProcess(pid) 时重启的问题</title>
    <!--mark |wiz_custom_css| for wizeditor replace it-->
<link rel="stylesheet"  name="wiz_tmp_editor_style" href="index_files/fonts_4.css"><style id="wiz_custom_css">html, body {            font-size: 15px;        }        body {            font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;            line-height: 1.6;            margin: 0;            padding: 20px 15px;            padding: 1.33rem 1rem;        }        h1, h2, h3, h4, h5, h6 {            margin: 20px 0 10px;            margin: 1.33rem 0 0.667rem;            padding: 0;            font-weight: bold;        }        h1 {            font-size: 21px;            font-size: 1.4rem;        }        h2 {            font-size: 20px;            font-size: 1.33rem;        }        h3 {            font-size: 18px;            font-size: 1.2rem;        }        h4 {            font-size: 17px;            font-size: 1.13rem;        }        h5 {            font-size: 15px;            font-size: 1rem;        }        h6 {            font-size: 15px;            font-size: 1rem;            color: #777777;            margin: 1rem 0;        }        div, p, ul, ol, dl, li {            margin: 0;        }        blockquote, table, pre, code {            margin: 8px 0;        }        ul, ol {            padding-left: 32px;            padding-left: 2.13rem;        }        blockquote {            padding: 0 12px;            padding: 0 0.8rem;        }        blockquote > :first-child {            margin-top: 0;        }        blockquote > :last-child {            margin-bottom: 0;        }        img {            border: 0;            max-width: 100%;            height: auto !important;            margin: 2px 0;        }        table {            border-collapse: collapse;            border: 1px solid #bbbbbb;        }        td, th {            padding: 4px 8px;            border-collapse: collapse;            border: 1px solid #bbbbbb;			        }        @media only screen and (-webkit-max-device-width: 1024px), only screen and (-o-max-device-width: 1024px), only screen and (max-device-width: 1024px), only screen and (-webkit-min-device-pixel-ratio: 3), only screen and (-o-min-device-pixel-ratio: 3), only screen and (min-device-pixel-ratio: 3) {            html, body {                font-size: 17px;            }            body {                line-height: 1.7;                padding: 0.75rem 0.9375rem;                color: #353c47;            }            h1 {                font-size: 2.125rem;            }            h2 {                font-size: 1.875rem;            }            h3 {                font-size: 1.625rem;            }            h4 {                font-size: 1.375rem;            }            h5 {                font-size: 1.125rem;            }            h6 {                color: inherit;            }            ul, ol {                padding-left: 2.5rem;            }            blockquote {                padding: 0 0.9375rem;            }        }</style><style id="wiz_tmp_editor_style" wiz_style= "unsave">html, body {    font-size: 15px;}body {    font-family: Helvetica, 'Hiragino Sans GB', 微软雅黑, 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;    line-height: 1.6;    color: ;    background-color: ;    margin: 0;    padding: 20px 15px;    padding: 1.33rem 1rem;}img{    max-width: 100%;}</style><script type="text/javascript" src="file:///D:\WizNote\WizTools\htmleditor\utils.js" wiz_style="unsave" charset="utf-8"></script><script type="text/javascript" src="file:///D:\WizNote\WizTools\htmleditor\localize.js" wiz_style="unsave" charset="utf-8"></script><script type="text/javascript" src="file:///D:\WizNote\WizTools\htmleditor\core\wizEditorForPc.js" wiz_style="unsave" charset="utf-8"></script><script type="text/javascript" src="file:///D:\WizNote\WizTools\htmleditor\editorHelper.js" wiz_style="unsave" charset="utf-8"></script><script type="text/javascript" src="file:///E:\我的为知\templates\WizTemplate.js" wiz_style="unsave" charset="utf-8"></script></head>

<body spellcheck="false" ><div class="article_title" style="margin-top: 5px; margin-bottom: 5px; font-stretch: normal; font-size: 20px; line-height: 30px; font-family: 'Microsoft YaHei'; background-color: rgb(255, 255, 255);"><span class="ico ico_type_Original" style="display: inline-block; width: 19px; height: 19px; margin: 0px 2px 0px 0px; vertical-align: middle; background: url(&quot;&quot;) 0px 0px no-repeat;"></span>&nbsp;<h1 style="margin-top: 0px; margin-bottom: 0px; display: inline; font-weight: normal; font-stretch: normal; font-size: 20px; vertical-align: middle;"><span class="link_title"><a href="http://blog.csdn.net/just_keep/article/details/42558579" style="color: rgb(0, 0, 0); text-decoration: none;">Android System.exit(code) and android.os.Process.killProcess(pid)或者发生RunTimeException 导致应用重启</a></span></h1></div><div class="article_manage clearfix" style="padding: 0px 20px 5px; color: rgb(153, 153, 153); font-stretch: normal; font-size: 12px; line-height: 22px; font-family: Arial; text-align: right; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(237, 237, 237); margin-right: -20px; margin-left: -20px; overflow: hidden; background-color: rgb(255, 255, 255);"><div class="article_l" style="width: 946.4px; float: left;"><span class="link_categories" style="margin: 0px 5px; float: left;">标签：&nbsp;<a href="http://www.csdn.net/tag/android" target="_blank" style="color: rgb(202, 0, 0); text-decoration: none; display: inline-block; margin-right: 10px;">android</a><a href="http://www.csdn.net/tag/System.exit" target="_blank" style="color: rgb(202, 0, 0); text-decoration: none; display: inline-block; margin-right: 10px;">System.exit</a><a href="http://www.csdn.net/tag/Process.killProcess" target="_blank" style="color: rgb(202, 0, 0); text-decoration: none; display: inline-block; margin-right: 10px;">Process.killProcess</a><a href="http://www.csdn.net/tag/RunTimeException" target="_blank" style="color: rgb(202, 0, 0); text-decoration: none; display: inline-block; margin-right: 10px;">RunTimeException</a><a href="http://www.csdn.net/tag/%e5%ba%94%e7%94%a8%e9%87%8d%e5%90%af" target="_blank" style="color: rgb(202, 0, 0); text-decoration: none; display: inline-block; margin-right: 10px;">应用重启</a></span></div><div class="article_r"><span class="link_postdate" style="margin: 0px 5px 0px 0px;">2015-01-09 19:08</span>&nbsp;<span class="link_view" title="阅读次数" style="margin: 0px 5px; padding: 0px 0px 0px 14px; background: url(&quot;&quot;) 0% 50% no-repeat;">1201人阅读</span>&nbsp;<span class="link_comments" title="评论次数" style="margin: 0px 5px; padding: 0px 0px 0px 14px; background: url(&quot;&quot;) 0% 50% no-repeat;"><a href="http://blog.csdn.net/just_keep/article/details/42558579#comments" style="color: rgb(202, 0, 0); text-decoration: none;">评论</a>(0)</span>&nbsp;<span class="link_collect tracking-ad" data-mod="popu_171" style="margin: 0px 5px;"><a title="收藏" target="_blank" style="color: rgb(202, 0, 0);">收藏</a></span>&nbsp;<span class="link_report" style="margin: 0px 5px;"><a href="http://blog.csdn.net/just_keep/article/details/42558579#report" title="举报" style="color: rgb(202, 0, 0); text-decoration: none;">举报</a></span></div></div><div class="category clearfix" style="margin-right: -20px; margin-left: -20px; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: rgb(237, 237, 237); padding: 5px 20px; font-family: Arial, Console, Verdana, 'Courier New'; font-size: 12px; line-height: normal; background-color: rgb(255, 255, 255);"><div class="category_l" style="display: inline-block; font-size: 14px; color: rgb(51, 51, 51); width: 70px; float: left; line-height: 28px;"><img src="index_files/0.1332104669418186.png" style="border-style: none; border-width: initial; vertical-align: middle;">&nbsp;<span style="display: inline-block; vertical-align: middle;">分类：</span></div><div class="category_r" style="display: inline-block; font-size: 14px; color: rgb(223, 52, 52); float: left; width: 851.75px;"><label style="display: inline-block; margin-left: 15px; cursor: pointer; line-height: 28px; position: relative;">Android（5）&nbsp;<img class="arrow-down" src="index_files/0.8853540881536901.png" style="border-style: none; border-width: initial; display: inline;"></label></div></div><div class="bog_copyright" style="padding: 20px 0px; font-family: Arial, Console, Verdana, 'Courier New'; font-size: 12px; line-height: normal; background-color: rgb(255, 255, 255);"><p class="copyright_p" style="padding: 0px 0px 0px 10px; height: 14px; line-height: 14px; border-left-width: 3px; border-left-style: solid; border-left-color: rgb(228, 28, 30); color: rgb(102, 102, 102); font-size: 14px;">版权声明：本文为博主原创文章，未经博主允许不得转载。</p></div><div id="article_content" class="article_content" style="margin-top: 20px; font-stretch: normal; font-size: 14px; line-height: 26px; font-family: Arial; background-color: rgb(255, 255, 255);"><p style="padding: 0px;"><span style="white-space: pre;"></span></p><p style="padding: 0px;">关于&nbsp;System.exit(code) and&nbsp;<a href="http://lib.csdn.net/base/15" class="replace_word" title="Android知识库" target="_blank" style="color: rgb(223, 52, 52); text-decoration: none; font-weight: bold;">Android</a>.os.Process.killProcess(pid) 或者发生RunTimeException导致应用重启 的问题，由于没有找到正式官方的文档说明，所以本人通过代码进行了一系列测试发现了某些规律</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">有不对的请知晓者告知。</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">首先在android中一个进程对应一个dalvik vm 实例，一个应用可以有一到多个进程也就是对应一到多个dalvik vm instance。一个应用可以有一到多个Task，每个Task 里面可以有一到多个TaskRecord。每个TaskRecord 对应了一个Activity。</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">OK，再来看一下api 文档时如何解释这两个方法的：</p><p style="padding: 0px;"><br></p><p style="padding: 0px;"><a target="_blank" href="http://developer.android.com/reference/java/lang/System.html#exit(int)" style="color: rgb(202, 0, 0); text-decoration: none;">System.exit(code)&nbsp;</a></p><p style="padding: 0px;"><span style="white-space: pre;"><span style="color: rgb(34, 34, 34); font-family: Roboto, sans-serif; line-height: 19px; background-color: rgb(249, 249, 249);">Causes the VM to stop running and the program to exit with the given exit status. If&nbsp;</span><code style="font-size: 13px; color: rgb(0, 102, 0); line-height: 14px; background-color: rgb(249, 249, 249);"><a target="_blank" href="http://developer.android.com/reference/java/lang/System.html#runFinalizersOnExit(boolean)" style="color: rgb(37, 138, 175); text-decoration: none;">runFinalizersOnExit(boolean)</a></code><span style="color: rgb(34, 34, 34); font-family: Roboto, sans-serif; line-height: 19px; background-color: rgb(249, 249, 249);">&nbsp;has
 been previously invoked with a&nbsp;</span><code style="font-size: 13px; color: rgb(0, 102, 0); line-height: 14px; background-color: rgb(249, 249, 249);">true</code><span style="color: rgb(34, 34, 34); font-family: Roboto, sans-serif; line-height: 19px; background-color: rgb(249, 249, 249);">&nbsp;argument,
 then all objects will be properly garbage-collected and finalized first.</span></span></p><p style="padding: 0px;"><span style="white-space: pre;"><span style="color: rgb(34, 34, 34); font-family: Roboto, sans-serif; line-height: 19px; background-color: rgb(249, 249, 249);"><br></span></span></p><p style="padding: 0px;"><a target="_blank" href="http://developer.android.com/reference/android/os/Process.html#killProcess(int)" style="color: rgb(202, 0, 0); text-decoration: none;">Process.killProcess(pid)</a></p><p style="padding: 0px;"><span style="white-space: pre;"><span style="color: rgb(34, 34, 34); font-family: Roboto, sans-serif; line-height: 19px; background-color: rgb(249, 249, 249);">Kill the process with the given PID. Note that, though this API allows us to request to kill
 any process based on its PID, the kernel will still impose standard restrictions on which PIDs you are actually able to kill. Typically this means only the process running the caller's packages/application and any additional processes created by that app;
 packages sharing a common UID will also be able to kill each other's processes.</span></span></p><p style="padding: 0px;"><span style="white-space: pre;"><span style="color: rgb(34, 34, 34); font-family: Roboto, sans-serif; line-height: 19px; background-color: rgb(249, 249, 249);"></span></span></p><p style="padding: 0px;">一个是Stop VM ,一个是Kill Process ,上面说了一个 进程对应一个 VM ，那么不管是调用哪一个方法都会用看到同样的效果</p><p style="padding: 0px;"><span style="white-space: pre;"><span style="color: rgb(34, 34, 34); font-family: Roboto, sans-serif; line-height: 19px; background-color: rgb(249, 249, 249);"><br></span></span></p><p style="padding: 0px;">当我们在代码中调用System.exit 或者 Process.KillProcess 的时候肯定会结束掉当前线程，但是会不会重启应用就要根据你调用结束时整个属于这个应用的所有Task的状态来决定：</p><p style="padding: 0px;">android中Task 是可以跨进程跨应用的，即不同应用的activity 可能运行在同一个Task &nbsp;中，System.exit 或者 Process.KillProcess 是根据什么来决定是否重启？重启的时候又是回到的哪一个界面（Activity）的呢？哪些界面会被重启？哪些又不会被重启呢？分为以下几部来说明：</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">首先：</p><p style="padding: 0px;">在每一个时刻Android 系统都有一个Task 列表，维护了当前系统中已启动的应用以及应用中各个界面（Activity）之间的顺序。比如：</p><p style="padding: 0px;"><span style="white-space: pre;"></span>Task 1 (App1)</p><p style="padding: 0px;"><span style="white-space: pre;"></span>--- taskrecord1 (Activity A) 栈顶</p><p style="padding: 0px;"><span style="white-space: pre;"></span>--- taskRecord2 (Activity B)栈底</p><p style="padding: 0px;"><br></p><p style="padding: 0px;"><span style="white-space: pre;"></span>Task 11(App1)<span style="white-space: pre;"></span></p><p style="padding: 0px;"><span style="white-space: pre;"></span></p><p style="padding: 0px;"><span style="white-space: pre;"></span>--- taskrecord1 (Activity c)</p><p style="padding: 0px;"><span style="white-space: pre;"></span>--- taskRecord2 (Activity d)</p><p style="padding: 0px;"><br></p><p style="padding: 0px;"><span style="white-space: pre;"></span>Task2(App 2)</p><p style="padding: 0px;"></p><p style="padding: 0px;"><span style="white-space: pre;"></span>--- taskrecord1 (Activity A)</p><p style="padding: 0px;"><span style="white-space: pre;"></span>--- taskRecord2 (Activity B)</p><p style="padding: 0px;"><br></p><p style="padding: 0px;"></p><p style="padding: 0px;"><span style="white-space: pre;"></span>Task2(App 3)</p><p style="padding: 0px;"></p><p style="padding: 0px;"><span style="white-space: pre;"></span>--- taskrecord1 (Activity C)</p><p style="padding: 0px;"><span style="white-space: pre;"></span>--- taskRecord2 (Activity D)</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">Task 有顺序，TaskRecord 也是有顺序的，假如当前Task 如上所说，那么 当前手机显示的就是 App1 这个应用程序的 ActivityA界面。</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">2：是否重启：</p><p style="padding: 0px;"><span style="white-space: pre;"></span>当调用System.exit 或者 Process.KillProcess 的时候，首先会结束掉执行该方法所在的进程，然后根据结束掉该应用的时候的该应用的所有Task 状态来决定是否重启， 如果退出时该应用所有Task 中的TaskRecord 数量大于一 就会重启，小于或等于一不会重启，整个应用就结束掉了</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">3:：重启后回到哪一个界面：</p><p style="padding: 0px;"><span style="white-space: pre;"></span>重启后会回到该应用的最上一个Task -当前显示的Task（因为一个应用可以有多个Task）中 栈顶的第二个TaskRecord（栈顶第一个将不会被重启），这也说明了为什么需要所有TaskRecord 的数量大于1的原因。</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">3：哪些会被重启，哪些不会？</p><p style="padding: 0px;"><span style="white-space: pre;"></span>上面第二条说了会回到第一个Task 的栈中的第二个TaskRecord,如果栈中在第二个下面还有其他TaskRecord 。那么在按返回键的时候会重新执行下一个TaskRecord &nbsp;对应Activity &nbsp;的onCreate 方法，依次类推，直到栈底为止。</p><p style="padding: 0px;"><br></p><p style="padding: 0px;"><br></p><p style="padding: 0px;"><br></p><p style="padding: 0px;">&nbsp;注意： 如果再Activity 的生命周期中执行System.exit 或者 Process.KillProcess 方法的时候一定要注意，在OnCreate ，OnStart，OnResum 的时候栈中是还没有存在该Activity对应的TaskRecord (该Activity还未被添加进去)，或者同样在OnPause,OnStop，onDestory 的时候，如果是按Back 那么该Activity &nbsp;对应的Activity 对应的TaskRecord 在执行System.exit 或者 Process.KillProcess 之前就已经被移除栈了，即在这种情况下会重启回到这个Activity 的上一个的上一个Activity(如果存在的话，如果不存在着直接退出了整个程序)。</p><p style="padding: 0px;"><br></p><p style="padding: 0px;"><br></p><p style="padding: 0px;">举例 1：</p><p style="padding: 0px;"><span style="white-space: pre;"></span>1：假如有一个App A , &nbsp;有3个Activity ：ActivityA，ActivityB，ActivityC。启动顺序为A 启动B ，B启动C</p><p style="padding: 0px;"><span style="white-space: pre;"></span>2：首先通过Launcher 启动了A 。如果在A中通过某个点击事件或者在A的OnCreate or onStart &nbsp;or onResum 方法，或者再A中按返回键的时候在OnStop or OnPause or OnDestroy 中触发了System.exit 或者 Process.KillProcess，那么程序将不会重启</p><p style="padding: 0px;"><span style="white-space: pre;"></span>3：如果 在A中启动了B ，并且A没有调用finish 方法，那么如果在B中的OnCreate or onStart &nbsp;or onResum 方法或者再B中按返回键的时候在OnStop or OnPause or OnDestroy 中触发了System.exit 或者 Process.KillProcess，那么程序也将不会重启，只有当B 启动完成，对应的TaskRecord 已经添加的Task 中了才会重启回到ActivityA。</p><p style="padding: 0px;">4：如果在B 中启动了C ，并且B 没有调用finish 方法，那么如果在C中的OnCreate or onStart &nbsp;or onResum 方法或者再C中按返回键的时候在OnStop or OnPause or OnDestroy 中触发了System.exit 或者 Process.KillProcess，那么程序将会重启，但是重启后回到的界面是A 而非B，应为此时C还未添加到Task 或者已经从Task里面移除了，所以会重启回到除去栈顶的B 的下一个也就是A。当然如果C启动完成已经添加到了Task里面，在C中通过某个点击事件获取其他方式触发了System.exit 或者 Process.KillProcess那么会重启回到B</p><p style="padding: 0px;"><br></p><p style="padding: 0px;">举例2：</p><p style="padding: 0px;"><span style="white-space: pre;"></span>1：有一个App B ,有5个Activity ： A，B，C，D，E 。其中A是启动Activity，启动顺序为 A-&gt;B-&gt;C-&gt;D-E</p><p style="padding: 0px;"><span style="white-space: pre;"></span>2：假如C的activity:process = "com.test.process1"，其他的Activity 使用默认的（名称和ApplicationID 一样），那么当A 启动了B 后B有启动了C ，只要是在C中不管任何地方调用了System.exit 或者 Process.KillProcess都会结束掉“com.test.process1”这个进程，其他进程不受影响，所以C Activity&nbsp;</p><p style="padding: 0px;"><span style="white-space: pre;"></span>会关闭，但是A ，B 保持原样。因为C已经关闭了更具Task 里面的顺序所以显示B 界面(效果和按返回键一样，只是说按返回键不会结束掉进程)；</p><p style="padding: 0px;"><span style="white-space: pre;"></span>3：接着第二种情况，假如不在C中调用，而是通过C启动了D，因为D 没有指定process ,所以D 和A，B 属于同一个进程。那么如果在D中执行了System.exit 或者 Process.KillProcess。那么会结束掉D所在的进程也就是默认名称的进程，而C 在的进程不受影响，因此再执行</p><p style="padding: 0px;"><span style="white-space: pre;"></span>System.exit 或者 Process.KillProcess后会显示C 界面不会立刻重启A,和B ，只有在C界面按返回的时候，这时候发现B 已经关闭了所以系统会自动重启B ，在B &nbsp;中按返回发现A也不存在了所以会自动重启A。针对此情况有一点需要补充一下，如果D 已经添加到Task 里面后执行的结束方法，那<span style="white-space: pre;"></span>么回到C ，和上面所说的不矛盾（只是C不需要重启因为C在单独的进程可以解释得通），那么如果是在D还未添加到Task 的时候，那么此时Task 里面只有A，B，C 三个。那么为什么任然回到C呢? 而不是B 呢？是因为C 在单独的进程所以不受影响，而顺序决定了C 在B 上面，所有只有回到C<span style="white-space: pre;"></span>而不是B</p><p style="padding: 0px;"><span style="white-space: pre;"></span>4：如果A，B，属于同一个进程，C,D,E 属于另一个进程，如果此时Task里面的状态时A-B-C-D-E。 E 在栈顶，那么在E 中执行了结束方法。会重启E 所在的进程回到界面D。在D中按返回重启C ，在C中按返回到B (不重启，不再同一个进程)</p><p style="padding: 0px;"><span style="white-space: pre;"></span>5：假如A，B，D 属于同一进程同一个Task 。C 在另一个进程并且另一个Task.那么当启动完成D后，整个应用就有两个Task 。最上一个（当前显示的）Task{TaskRecordA，TaskRecord,B，TaskReocedD}，以及另一个Task{TaskRecordC}。那么在D中执行结束方法，会重启回到B界面，返<span style="white-space: pre;"></span>回的顺序是B-&gt;A-&gt;C.其中B，A 会重启，C不会</p><br><p style="padding: 0px;">总结：总的来说就是当调用System.exit 或者 Process.KillProcess的时候，只会结束当前调用的进程（如果一个应用有多个进程，其他进程不会发生改变，其他进程里面的activity 也不会重起），在根据结束之前整个应用的Tasks 状态（数量和顺序）来决定时候重启，数量决定是否重启，顺序决定重<span style="white-space: pre;"></span>启后回到哪一个界面。</p><p style="padding: 0px;"><br></p><p style="padding: 0px;"><span style="color: rgb(204, 0, 0);">同样当发生RunTimeException 的时候和System.exit 或者 Process.KillProcess效果是一样的。</span></p><br><div style="color:gray"><small>来源：&nbsp;<a href="http://blog.csdn.net/just_keep/article/details/42558579">http://blog.csdn.net/just_keep/article/details/42558579</a></small></div></div></body></html>